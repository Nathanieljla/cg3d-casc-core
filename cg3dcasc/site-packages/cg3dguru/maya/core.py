import typing
import tempfile
import os
import pathlib

import csc
import rig_mode.on as rm_on
import rig_mode.off as rm_off

import cg3dguru.core
import cg3dguru.core.general.fbx as fbx


MAYA_BEHAVIOUR_NAME = 'Maya Data'



def _import_maya_qrig_file(file_path):
    scene_manager = csc.app.get_application().get_scene_manager()
    application_scene = scene_manager.current_scene()
    rm_on.run_raw(application_scene.domain_scene(), [0.0, 0.5, 0.0])
    rig_tool = csc.app.get_application().get_tools_manager().get_tool('RiggingToolWindowTool').editor(application_scene)
    rig_tool.open_quick_rigging_tool()
    rig_tool.load_template_by_fileName(file_path)
    rig_tool.generate_rig_elements()
    

    
def _get_object_by_id(object_list, maya_id):
    global MAYA_BEHAVIOUR_NAME
    
    for obj in object_list:
        beh = obj.get_behaviour_by_name(MAYA_BEHAVIOUR_NAME)
        if beh:
            found_id = beh.datasWithSameNamesReadonly.get_by_name('maya_id')
            if found_id and found_id[0].get() == maya_id:
                print('found previous import')
                return obj
        
    return None
    
    

def _create_data(scene, set_name, maya_id, new_roots):
    global MAYA_BEHAVIOUR_NAME
        
    obj = scene.create_object(set_name)
    behaviour = obj.add_behaviour('Dynamic', MAYA_BEHAVIOUR_NAME)
    data_prop = behaviour.get_property('datasWithSameNamesReadonly')
    data_prop.create_data('maya_id', csc.model.DataMode.Static, maya_id, group_name='{} update'.format(MAYA_BEHAVIOUR_NAME))
    
    roots_behaviour = obj.add_behaviour('DynamicBehaviour', 'Maya Roots')
    roots_behaviour.behaviours.set( [obj.Basic for obj in new_roots] )
    
    
    
def _get_modified_filter(existing_data, qrig_path, import_filter: fbx.FbxFilterType):
    if import_filter == fbx.FbxFilterType.ANIMATION:
        return fbx.FbxFilterType.ANIMATION
    elif import_filter == fbx.FbxFilterType.MODEL:
        return fbx.FbxFilterType.MODEL
    elif import_filter == fbx.FbxFilterType.SCENE:
        return fbx.FbxFilterType.SCENE
    elif import_filter == fbx.FbxFilterType.AUTO:
        if existing_data is None:
            #If no data exists, we'll import everything
            print("Importing scene")
            return fbx.FbxFilterType.SCENE
        elif qrig_path:
            #Else if we have data and a qrig_path exists, we'll assume
            #they just want to quick-rig the previous data
            print("Skpping FBX Data")
            return fbx.FbxFilterType.SKIP
        else:
            #else we'll assume only animation data needs updating
            print("Importing Animation")
            return fbx.FbxFilterType.ANIMATION
    else:
        raise (Exception("Add support for {}".format(import_filter)))
    
    
    
def _import_maya(new_scene, import_filter: fbx.FbxFilterType):
    if new_scene:
        scene = cg3dguru.core.new_scene()
    else:
        scene = cg3dguru.core.get_current_scene()

    scene.dom_scene.info("Importing Maya Data")
    temp_dir = pathlib.Path(os.path.join(tempfile.gettempdir(), 'mayacasc'))
    if not temp_dir.exists():
        scene.dom_scene.error("Can't find Maya data")
        return
    
        
    #pre_import_roots will allow me to find everything that's new to the
    #scene once all files are imported.  scene_roots will be updated
    #after each file to import has been imported.
    pre_import_roots = set(scene.get_scene_objects(only_roots=True))
    scene_roots = set(pre_import_roots)
    
    files = {}
    for child in temp_dir.iterdir():
        name, ext = child.name.rsplit('.', 1)
        if name not in files:
            files[name] = dict()
            
        files[name][ext.lower()] = str(child)
        
        
    for key, item in files.items():
        fbx_path = ''
        qrig_path = ''
        if 'fbx' in item:
            fbx_path = item['fbx']
        if 'qrigcasc' in item:
            qrig_path = item['qrigcasc']
            
        set_name, maya_id = key.split('.') 
        existing_data = _get_object_by_id(pre_import_roots, maya_id)
        modified_filter = _get_modified_filter(existing_data, qrig_path, import_filter)
        
        if modified_filter != fbx.FbxFilterType.SKIP:
            fbx.import_fbx(fbx_path, modified_filter)


        #Let's find the stuff that was just imported and create a way
        #to search for it later.
        current_roots = set(scene.get_scene_objects(only_roots=True))
        new_roots = current_roots.difference(scene_roots)
        scene_roots = current_roots
        
        if existing_data is None:
            scene.edit('Import maya data', _create_data, set_name, maya_id, new_roots)
        else:
            scene.dom_scene.info("Updated existing data")
                
        #rig generation has to come last, so all the other automation can complete properly
        if qrig_path:
            _import_maya_qrig_file(qrig_path)
            
            
            
def update_models():
    _import_maya(False, fbx.FbxFilterType.MODEL)
    
    
def update_animations():
    _import_maya(False, fbx.FbxFilterType.ANIMATION)
    

def import_scene(new_scene):
    _import_maya(new_scene, fbx.FbxFilterType.SCENE)
    
    
def smart_import(new_scene):
    _import_maya(new_scene, fbx.FbxFilterType.AUTO)
        
        
def export_maya_fbx_animation():
    import wingcarrier.pigeons
    maya = wingcarrier.pigeons.MayaPigeon()    
    maya.send_python_command('print("hi")')
    
    
def run(*args, **kwargs):
    print("Run function called")
    #import_maya_model(False)
    
  
print('core imported')  
    
#if __name__ == '__main__':
    #print("Importing")
    #import_fbx_file()
    


